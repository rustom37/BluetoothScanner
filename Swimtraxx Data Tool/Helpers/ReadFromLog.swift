//
//  ReadFromLog.swift
//  BluetoothScanner
//
//  Created by Steve Rustom on 14/04/2021.
//  Copyright Â© 2021 Steve Rustom. All rights reserved.
//

import Foundation

/// Decodes the raw line in which the time stamp is situated and returns the information in a list with the following structure [day, month, year, hour, min, sec, fracSec, decodedClockService].
/// The line in which the time stamp is situated contains of following information (from right to left):
/// - Information on the time (4 bytes)
/// - Information on clock service (2 bytes)
/// - Information on the date (3 bytes)
/// - Filling information (5 bytes)
/// - Status bit (which is 6) (1 byte)
/// It contains the information in hexadecimal numbers.
/// - Parameter rawLine: Unprocessed line of data.
/// - Returns: The information on the time and date in a list with the following structure [day, month, year, hour, min, sec, fracSec, decodedClockService]
func decodeTimestampLine(rawLine: String) -> [String] {
    var timeStamp: [String] = []

    if let day = UInt16(rawLine[12..<14]) {
        timeStamp.append(String(day))
        if let month = UInt16(rawLine[14..<16]) {
            timeStamp.append(String(month))
            if let year = UInt16(rawLine[16..<20]) {
                timeStamp.append(String(year))
                if let hour = UInt16(rawLine[24..<26]) {
                    timeStamp.append(String(hour))
                    if let min = UInt16(rawLine[26..<28]) {
                        timeStamp.append(String(min))
                        if let sec = UInt16(rawLine[28..<30]) {
                            timeStamp.append(String(sec))
                            if let fracSec = UInt16(rawLine[30..<32]) {
                                timeStamp.append(String(fracSec))
                                if let codedClockService = UInt16(rawLine[20..<24]) {
                                    if codedClockService == 43690 {
                                        timeStamp.append("CTS")
                                    } else {
                                        timeStamp.append("RTC")
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return timeStamp
}

/// Function which decodes the hexadecimal string for each sample generated by the measurement device.
/// - Parameter rawData: List where each element is a sample encoded in hexadecimal number.
/// - Returns: A tuple of nested lists. The left hand side is a nested list, each element of the list is a sample. Each sample itself is a list containing the values of the sensors. The structure of this list for each sample is following: [ppg, accelerometer_x, accelerometer_y, accelerometer_z, gyroscope_x, gyroscope_y, gyroscope_z]. The right hand side is a nested list is a nested list, each element of the list contains information on date and time.
func decodeData(rawData: [String]) -> ([[[Int16]]], [[String]]) {
    var sensorDataMultipleMeasurements: [[[Int16]]] = []  // raw_sensor_data array for each measurement is saved in this array.
    var headerDataMultipleMeasurements: [[String]] = []
    var sensorDataSingleMeasurement: [[Int16]] = []  // sensor data per measurement is saved in this array
    var counterEndOfMeasurement = 0
    var headerData: [String] = []
    var previousStatus = 7

    for (index, line) in rawData.enumerated() {
        // Remove any space at the left and right sides of the string
        let strippedLine = line.trimmingCharacters(in: .whitespaces)
        if strippedLine[0] == "0" {
            if let data = Data(fromHexEncodedString: strippedLine) {
                do {
                    let res = try unpack(">Ihhhhhh", data)
                    var ppg = res[0] as! Int
                    let status = ppg >> 24
                    ppg = ppg & 0x00FFFFFF  // Clear status bits

                    if status == 6 {
                        headerData = decodeTimestampLine(rawLine: line)
                    }

                    if status == 1 { // Status bit 1 indicates the start of a measurement
                        sensorDataSingleMeasurement = []
                        counterEndOfMeasurement = 0
                        headerDataMultipleMeasurements.append(headerData)
                    } else if status == 6 && previousStatus == 0 {
                        if counterEndOfMeasurement == 0 && index != 0 {
                            sensorDataMultipleMeasurements.append(sensorDataSingleMeasurement)
                        }
                        counterEndOfMeasurement += 1
                    } else if status == 0 && index == (rawData.count -  6) {
                        if counterEndOfMeasurement == 0 && index != 0 {
                            sensorDataMultipleMeasurements.append(sensorDataSingleMeasurement)
                        }
                        counterEndOfMeasurement += 1
                    } else if status == 0 { // Status bit 0 indicates that a measurement is going on
                        let acc_x = res[1] as! Int
                        let acc_y = res[2] as! Int
                        let acc_z = res[3] as! Int
                        let gyro_x = res[4] as! Int
                        let gyro_y = res[5] as! Int
                        let gyro_z = res[6] as! Int
                        let sensorDataSample: [Int16] = [Int16(ppg), Int16(acc_x), Int16(acc_y), Int16(acc_z), Int16(gyro_x), Int16(gyro_y), Int16(gyro_z)]
                        sensorDataSingleMeasurement.append(sensorDataSample)
                    }
                    previousStatus = status
                } catch {
                    print("Cannot unpack data.")
                }
            }
        }
    }
    sensorDataMultipleMeasurements.append(sensorDataSingleMeasurement)
    return (sensorDataMultipleMeasurements,headerDataMultipleMeasurements)
}

extension String {

    var length: Int {
        return count
    }

    subscript (i: Int) -> String {
        return self[i ..< i + 1]
    }

    func substring(fromIndex: Int) -> String {
        return self[min(fromIndex, length) ..< length]
    }

    func substring(toIndex: Int) -> String {
        return self[0 ..< max(0, toIndex)]
    }

    subscript (r: Range<Int>) -> String {
        let range = Range(uncheckedBounds: (lower: max(0, min(length, r.lowerBound)),
                                            upper: min(length, max(0, r.upperBound))))
        let start = index(startIndex, offsetBy: range.lowerBound)
        let end = index(start, offsetBy: range.upperBound - range.lowerBound)
        return String(self[start ..< end])
    }
}

extension Data {
    init?(fromHexEncodedString string: String) {

        // Convert 0 ... 9, a ... f, A ...F to their decimal value,
        // return nil for all other input characters
        func decodeNibble(u: UInt16) -> UInt8? {
            switch(u) {
            case 0x30 ... 0x39:
                return UInt8(u - 0x30)
            case 0x41 ... 0x46:
                return UInt8(u - 0x41 + 10)
            case 0x61 ... 0x66:
                return UInt8(u - 0x61 + 10)
            default:
                return nil
            }
        }

        self.init(capacity: string.utf16.count/2)
        var even = true
        var byte: UInt8 = 0
        for c in string.utf16 {
            guard let val = decodeNibble(u: c) else { return nil }
            if even {
                byte = val << 4
            } else {
                byte += val
                self.append(byte)
            }
            even = !even
        }
        guard even else { return nil }
    }
}
